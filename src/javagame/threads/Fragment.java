////The initialize() method creates all three thread pools and creates 100 callable tasks that simulate loading 100 files. The processInput() method submits each task to the different thread pools. If you press 1, the single threaded pool is used. The 2 key uses the thread pool with a maximum of 32 threads. The 3 key uses the unlimited cached thread pool.  The updateObject() method loops through the list of Future tasks and removes any completed tasks. The render() method displays the usual directions and the percentage of tasks complete. The terminate() method shuts down each thread pool before the application shuts down.
////We have seen that the primitive numeric types are not objects, but sometimes we need to process primitive‐type data as objects. For example, we may want to pass a numeric value to a method that requires an object as its argument. Java provides a set of classes called wrapper classes whose objects contain primitive‐type values: Float, Double, Integer, Boolean, Character, and so on. These classes provide constructor methods to create new objects that “wrap” a specified value. They also provide methods to “unwrap,” or extract, an object’s value and methods to compare two objects. Table A.13 shows some methods for wrapper class Integer (part of java.lang). The other numeric wrapper classes also provide these methods, except that method parseInt is replaced by a method parseClassType, where ClassType is the data type wrapped by that class.  In earlier versions of Java, a programmer could not mix type int values and type Integer objects in an expression. If you wanted to increment the value stored in Integer object nInt, you would have to unwrap the value, increment it, and then wrap the value in a new Integer object:
//int n = nInt.intValue();
//nInt = new Integer(n++);
////Java 5.0 introduced a feature known as autoboxing/unboxing for primitive types. This enables programmers to use a primitive type in contexts where an Object is needed or to use a wrapper object in contexts where a primitive type is needed. Using autoboxing/unboxing, you can rewrite the statements above as
//int n = nInt;
//nInt = n++;
//or even as the single statement:
//nInt++;
//The distance (d) above and the sum of (r1) and (r2) are used to determine if the objects overlap. If any one of the tests fails, then the objects do not overlap. If no axis has a separation between objects, then they intersect, provided the objects do not curve about each other. One good thing about this method is that it works in more than two dimensions. In the previous illustration, the only axis that does not have an overlap is (n3).
//The RectRectOverlapExample, as shown in Figure 7.24 and located in the javagames.  intersection package, holds the four points of a base rectangle that is copied for each of the two rectangles tested in the example. Each rectangle testing for overlap has an array of points, a position, and a rotation in radians. The intersection variable holds the state of the separating axis test.
